
2. 感知器增加发生错误时重新规划的接口，需要终止全部的子进程和子线程，然后主进程规划器启动，再按顺序执行；所以需要线程和进程的管理；

4. 集中式启动中存在的问题：上升高度不够，随机飞行算法需要改进,无人机感知器不准确，导致稳定性差


日志系统：
每次系统启动，就是一个任务的执行，会有一个唯一标识符id，创建一个这个id的文件，用于记录本次任务的所有日志和消息
分别是：
task.log: 记录任务相关的日志，从任务接收器到任务调度器
drone_xxx.log: 记录无人机相关的日志，无人机执行器，无人机监控器，无人机感知器的日志
script_xxx.log: 记录xxx脚本执行中的日志
connect.log: 记录有关于网络连接的日志
message_xxx.log: 记录xxx设备接收到的消息的日志

关于消息的设计
message的格式要求：        
{
    msg_type:"",
    msg_len:"",
    msg_content:"",
}
1. 发送脚本的消息：
类型是"script"，内容就是 脚本代码
2. 通知任务进度的消息
类型是"task_progress"，内容是 {"task":"task.name","state":"finish/error/running","reason":"reason"}
3. 启动通知的消息
类型是"start_notice"，内容是 {"finished_task":"task.name"}
4. 错误消息
类型是"error"，内容 
5. 传递数据的消息
类型是"data"，内容是 {"data_name":"data_content"}
数据的种类有：
position:[x,y,z]
time：duration
unknown：data
6. 自定义的消息
类型是：unknown，内容自定义
7. 突发情况的消息
类型是：interrupt ,内容是python脚本还是子任务呢？


√1. 提前启动无人机，使其能够正确的建立连接
√2. 维持连接的部分写的p2pnode里面，通过add添加需要连接的设备，由p2pnode启动线程一直尝试连接
√3. 修复了感知器调度器的一些错误


√1. 增加自定义消息，以及处理接口
√2. 脚本执行的日志单独记录
3. 无人机感知器对于任务进度的感知不准确，进而导致任务感知器的处理不准确        
√4. 关于数据传递的问题，是否获取到存疑
√5. 测试两种启动的调度功能，保证双任务可以运行
6. 进程线程的控制，便于终止程序和错误处理


终止处理：
对于进程线程，目前有主进程，即接收器、规划器。。。。调度器，主进程启动的线程有任务感知器，连接维护器。
主进程为每台无人机启动管理进程，管理进程启动每台无人机的三个线程。
主进程记录所有无人机的进程，关闭时直接强制终止进程，里面的线程自动终止，但是可能存在问题。另外需要终止任务感知器和所有的连接和连接维护器
出现错误需要重新规划时调用终止方法，并清空调度器属性，从规划器在启动


突发处理情况：
给无人机下发新任务
应该是通过网络连接发送给无人机，由无人机的感知器进行处理，发送
新的子任务？ 脚本？
无人机感知器根据消息类型进行接收，然后让无人机执行器执行，所以发送的应该是可执行的脚本，如果是子任务，需要进行翻译
那么这个脚本该怎么插入到正在执行的脚本中呢？
先看无人机执行器是如何执行脚本的：
集中式是通过调度器发送脚本，由感知器感知到，然后调用执行方法的
分布式是将脚本保存到了类属性中，由感知器感知任务的启动，然后取出脚本执行的

可以尝试设计函数库中的interrupt函数，看能否让运行中的脚本感知到中断，然后脚本结束。
对于集中式的，就让感知器将突发任务优先处理，调用执行方法
对于分布式的，尝试修改分布式运行方法，增加优先处理突发的功能，让感知器修改执行器属性

恢复原任务或清空：
清空：集中式需要清空调度器中的内容，或者不处理，让它调度不了。分布式需要把子任务列表清空。
恢复：那就需要先保存任务，重新运行这个任务

之前没有考虑到两个执行脚本同时运行的情况，可能bug  连续的突发任务，先发布的会被后发布的打断



运行稳定性和准确性的优化：
json格式输出不稳定
两个感知器的方法，慢，改进
目标识别和定位的准确性
无人机搜索脚本的优化


√1. 任务初始化器中，在main函数中会执行，删除任务调度器中重复执行的部分
√2. 每个无人机的p2p节点初始化在无人机管理器中执行，并且增加添加连接节点函数
√3. 集中式启动的无人机执行脚本不通过感知器执行，改为由执行器执行
4. 突发处理方法，改为通过优先级控制，在执行器中增加栈，用于恢复任务



关于突发任务的设计：
对于脚本的基本函数不做改动，还是interrupt方法，
正常的任务分解会不会有优先级呢？不需要
如果出现突发任务，每个突发任务由一个优先级，对于突发任务有一套单独的处理流程
首先，程序会启动一个web服务器，或者是其他，用于接收突发任务。任务调度器接收这个任务，这个任务是一个子任务，
额外有两个属性：优先级和是否恢复
调度器会将这个任务发送给对应无人机，消息类型是：interrupt，对应无人机会接收消息，发现是interrupt类型的消息，
然后调用翻译器，生成这个消息的代码，然后交给执行器取处理
执行器会有一个栈，用于恢复任务。 接受的时候的参数有：优先级，是否恢复，子任务，代码




系统将普通任务（也就是正常流程中任务分解得到的子任务）视为最低优先级（0级），而突发任务根据重要性分配不同的优先级数值（数值越大，优先级越高）。

数据结构
1. 任务栈：执行器中维护的一个列表，用于存储被中断的任务信息，包括：
脚本内容
任务优先级
子任务对象

2. 中断消息：包含四个关键属性：
中断任务的优先级
是否在完成后恢复原任务
子任务对象
要执行的脚本代码

3. 突发任务优先级队列：用于保存未能执行的突发任务


整体设计：
### 1. TaskScheduler负责接收突发子任务

1. 通过Web服务器或其他接口接收突发子任务
2. 任务调度器将任务封装成包含优先级和恢复标志的中断消息
3. 通过P2P网络发送给目标无人机

### 2. DronePerceptor接收消息
1. 无人机感知器接收消息并识别为"interrupt"类型
2. 感知器解析消息内容，提取优先级、恢复标志、子任务和代码
3. 将解析后的中断任务传递给执行器处理

### 3. 任务执行器的处理

1. 执行器收到中断任务后，首先比较优先级
    如果新任务优先级小于等于当前任务，则拒绝中断，记录日志后返回。如果新任务优先级更高，且当前有任务在执行：
   - 如果需要恢复，则创建包含当前任务脚本、优先级和子任务对象的任务信息，将当前任务信息保存到任务栈
   - 如果不需要，直接清空当前的任务，不需要保存
2. 设置新的子任务对象，优先级为新任务的优先级
3. 开始执行中断任务

### 3. 中断任务执行过程

1. 先设置`interrupt_flag`标志为True，终止当前正在执行的任务，然后恢复标志为Fasle
2. 临时保存中断任务代码为当前脚本
3. 构建全局命名空间，包含无人机ID、监控器、P2P节点等必要对象，使用Python的exec()函数执行任务代码
4. 任务完成或出现异常时，调用恢复函数检查是否需要恢复之前的任务

### 4. 任务恢复机制

1. 检查任务栈是否为空
2. 如果栈非空，从栈顶弹出最近被中断的任务
3. 恢复任务的属性：
   - 将子任务对象设置回原来的子任务
   - 将当前优先级设置为原任务的优先级
   - 将当前脚本设置为原任务的脚本
4. 执行恢复的任务
5. 如果栈为空，则重置当前优先级为0（普通任务级别）


突发任务可以中断突发任务，根据优先级来进行判断，如果有突发任务被中断或者无法执行，将其暂存到优先级队列内，
当该无人机的当前任务执行完成后，先检查这个队列，根据优先级执行

目前存在的问题：
1. 分布式的执行器逻辑与集中式不同，分布式的突发处理需要修改
2. 中断信号不一定能够接收到
3. 恢复函数有问题，导致指令多次重复

另外当前的设计存在问题：中断的检查是在脚本文件中每次循环会检查一次，这导致：
1.不能够及时的相应中断，至少需要等待本次循环结束
2.中断标志位的设置需要中断一段时间后恢复，再去执行中断任务。否则，中断任务中就不能出现中断函数。
因此这就导致，中断标志为设置的时间必须要比循环的时间长，但是循环的时间不确定


将无人机启动放在taskManager
